Dispatcher Servlet Flow:

Browser (GET /home)
        â†“
Tomcat (Servlet container)
        â†“
DispatcherServlet (Front Controller)
        â†“
HandlerMapping â†’ Finds Controller
        â†“
HandlerAdapter â†’ Calls Controller
        â†“
Controller executes (adds model, returns "home")
        â†‘
Back to DispatcherServlet
        â†“
ViewResolver â†’ /WEB-INF/views/home.jsp
        â†“
DispatcherServlet forwards to JSP
        â†“
JSP renders HTML
        â†“
Response â†’ Browser

Step	Who					        What Happens
1	    Browser				      Sends request
2	    Tomcat				      Forwards to DispatcherServlet
3	    DispatcherServlet	  Main entry point, orchestrates the whole flow
4	    HandlerMapping		  Finds correct Controller
5	    HandlerAdapter		  Invokes Controller method
6	    Controller			    Runs logic, returns view name
7	    DispatcherServlet	  Gets back model + view name
8	    ViewResolver		    Maps view name â†’ actual JSP
9	    JSP					        Renders HTML
10	  DispatcherServlet	  Sends final response
11	  Browser				      Displays result

Spring MVC Full Requestâ€“Response Lifecycle

ğŸ§­ Step 1 â€” Browser Sends a Request

User opens:

http://localhost:8080/SpringMVCApp/home


This is an HTTP GET request.

ğŸ§© Step 2 â€” Tomcat receives the request

Tomcat looks in web.xml and says:

â€œThis URL pattern / is handled by the servlet named app â†’ DispatcherServlet.â€

So it forwards the request to Springâ€™s DispatcherServlet.service() method.

âš™ï¸ Step 3 â€” DispatcherServlet Takes Control

This is where the Spring MVC magic begins.

Internally, DispatcherServlet calls:

doDispatch(request, response)

Inside this method, the real flow starts.

Step-by-Step Inside DispatcherServlet

Letâ€™s open it up.

ğŸ§© Step 4 â€” HandlerMapping

DispatcherServlet asks all HandlerMapping beans:

â€œWhich controller should handle /home?â€

HandlerMapping looks at all @RequestMapping annotations in your controllers.

It finds:

@RequestMapping("/home")
public String home(Model model)


and says:

â€œHomeControllerâ€™s home() method should handle this request.â€

âœ… A HandlerExecutionChain (controller + interceptors) is returned.

ğŸ§© Step 5 â€” HandlerAdapter

DispatcherServlet now needs to execute that method.
But controllers can be of different types (annotation-based, simple, etc.),
so it uses a HandlerAdapter that knows how to call it.

It finds an adapter that supports @RequestMapping methods and calls:

handlerAdapter.handle(request, response, handler);

ğŸ§© Step 6 â€” Controller Execution

Now your controller method runs:

@Controller
public class HomeController {

    @RequestMapping("/home")
    public String home(Model model) {
        model.addAttribute("name", "Paurush");
        return "home";   // logical view name
    }
}


âœ… It adds data to the Model.
âœ… Returns logical view name = "home".

ğŸ§© Step 7 â€” Back to DispatcherServlet

After the controller returns, control goes back to the DispatcherServlet.

DispatcherServlet now has:

The Model (data like â€œname: Paurushâ€)

The View name ("home")

So yes âœ… the flow comes back to the DispatcherServlet at this point.

ğŸ§© Step 8 â€” ViewResolver

DispatcherServlet now asks the ViewResolver:

â€œPlease convert logical view name home into a real view file.â€

ViewResolver does this:

prefix + viewName + suffix
= /WEB-INF/views/ + home + .jsp
= /WEB-INF/views/home.jsp


It returns a View object.

ğŸ§© Step 9 â€” DispatcherServlet renders the View

Now DispatcherServlet calls:

view.render(model, request, response);


That means:

It sets model attributes in the request

Forwards the request to the JSP

ğŸ§© Step 10 â€” JSP executes and produces HTML

home.jsp uses ${name} to display the value:

<h1>Welcome, ${name}!</h1>


The JSP is processed by the JSP engine â†’ converted into HTML.

ğŸ§© Step 11 â€” Response travels back

The generated HTML response goes:

JSP â†’ DispatcherServlet â†’ Tomcat â†’ Browser


âœ… DispatcherServlet sends the final response object back through the servlet container.
âœ… The browser renders it as a web page.
